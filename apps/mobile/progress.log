# Progress Log - MedSync Mobile
# This file tracks the development history of the mobile application

---

MedSync Mobile initialized with Expo on 2025-12-12

---

[2025-12-12] [MOBILE-INIT] Initial Expo project setup - COMPLETED
- Created React Native project using Expo SDK 54
- Configured app.json with app name "MedSync", slug "medsync"
- Set up project owner (thsdeveloper) and EAS project ID
- Configured iOS and Android adaptive icons with custom branding
- Enabled Expo Router for file-based navigation
- Configured splash screen with custom icon and dual theme support (light/dark)
- Enabled experimental features: typed routes and React Compiler
- Set up runtime version policy based on app version
- Configured OTA updates via Expo Updates
- All platform configurations verified (iOS, Android, Web)

---

[2025-12-12] [MOBILE-AUTH] Authentication system implementation - COMPLETED
- Integrated Supabase client with custom storage adapter
- Created ExpoSecureStoreAdapter for secure credential storage
  * iOS/Android: uses Expo SecureStore for encrypted storage
  * Web: falls back to localStorage
- Configured Supabase auth with auto-refresh tokens and persistent sessions
- Implemented AuthProvider context (providers/auth-provider.tsx)
  * Session state management
  * Staff data loading from medical_staff table
  * Sign in/sign out functionality
  * Loading states and error handling
- Created authentication flow screens:
  * (auth)/index.tsx - Initial CRM input screen
  * (auth)/login.tsx - Password login for existing users
  * (auth)/register.tsx - New user registration
  * (auth)/setup-password.tsx - Password setup for first-time users
- Implemented CRM lookup functionality (lookupStaffByCrm)
  * Validates CRM against medical_staff table
  * Checks if user already has auth credentials (user_id)
  * Returns staff details for registration flow
- Created getCurrentStaff() helper function
  * Fetches medical_staff record for authenticated user
  * Used throughout app for staff data access
- Built CRMInput UI component with input masking
- Implemented secure password input fields
- Added loading states and error messages throughout auth flow
- Protected routes with auth state checks
- Automatic redirect to auth screens if not authenticated

---

[2025-12-12] [MOBILE-SHIFTS] Shift management system - COMPLETED
- Created shift listing and calendar views
- Implemented HomeScreen (app/(app)/(tabs)/index.tsx)
  * Elegant gradient header with user greeting (Bom dia/Boa tarde/Boa noite)
  * Dynamic greeting icons (sun/partly-sunny/moon) based on time of day
  * Display of next 3 upcoming shifts with ShiftCard components
  * Pending actions alert card showing pending accepts and swap requests
  * Quick action buttons (Escalas, Trocas, Chat, Perfil)
  * Pull-to-refresh functionality
  * Real-time shift updates via useRealtimeShifts hook
  * Badge notifications for pending shifts and swap requests
- Implemented ScheduleScreen (app/(app)/(tabs)/schedule.tsx)
  * Full calendar view using react-native-calendars
  * Multi-dot markers showing shifts by status (pending=yellow, accepted=green)
  * Filter by status (all, pending, accepted)
  * Day selection showing shifts for selected date
  * Month navigation with automatic data loading
  * Bulk actions banner for pending shifts
  * "Accept All" and "Decline All" bulk operations
  * Individual shift cards with compact variant
  * Real-time updates for shift changes
- Created ShiftDetailScreen (app/(app)/shift/[id].tsx)
  * Complete shift information display
  * ShiftDetailHeader component with animated sky scene
  * ShiftDetails component with all shift metadata
  * Check-in/Check-out functionality integration
  * Request Swap button for creating swap requests
  * Accept/Decline actions for pending shifts
  * Navigation to related swap requests
- Built ShiftCard organism component
  * Two variants: "full" and "compact"
  * Status badges (pending, accepted, declined)
  * Period badges (manhã, tarde, noite)
  * Sector color indicators
  * Facility information
  * Date and time display with duration
  * Tap to navigate to shift details
- Implemented shift data fetching with Supabase
  * Queries with relations: sectors, organizations, facilities, attendance
  * Filtered by staff_id for current user
  * Ordered by start_time
  * Date range filtering for calendar view
- Created useRealtimeShifts custom hook
  * Subscribes to shift table changes
  * Automatically updates shift list on INSERT/UPDATE/DELETE
  * Calculates pending count for badges
  * Merges realtime updates with fetched data

---

[2025-12-12] [MOBILE-SWAPS] Shift swap request system - COMPLETED
- Implemented RequestsScreen (app/(app)/(tabs)/requests.tsx)
  * Tabbed interface: "Recebidas" and "Enviadas"
  * Badge counter for pending incoming requests
  * Request cards showing requester/target info with Avatar
  * Status badges (pendente, aceita, recusada, cancelada)
  * Preview of both shifts involved in swap
  * Requester notes display
  * "Tap to respond" hint for pending received requests
  * Pull-to-refresh functionality
  * Empty states with helpful messages
- Created SwapDetailScreen (app/(app)/swap/[id].tsx)
  * Complete swap request information
  * Both shifts displayed with full details
  * Requester and target staff information
  * Status tracking with colored badges
  * Accept/Decline buttons for received requests
  * Cancel button for sent requests
  * Confirmation dialogs for all actions
  * Success/error toast messages
- Implemented RequestSwapScreen (app/(app)/shift/[id]/request-swap.tsx)
  * Form to create new swap request
  * Original shift display (the one being swapped)
  * Optional target shift selection (shift desired in return)
  * Notes/justification text input
  * Validation before submission
  * Success feedback and navigation
- Built useRealtimeSwapRequests custom hook
  * Subscribes to shift_swap_requests table changes
  * Real-time updates for new requests and status changes
  * Calculates pending incoming count for notifications
  * Filters requests by requester and target staff
- Implemented swap request database operations
  * Create swap request with shift IDs and notes
  * Accept swap: updates both shifts' staff assignments
  * Decline swap: updates request status to declined
  * Cancel swap: allows requester to cancel pending requests
- Added swap request validations
  * Prevents swapping already swapped shifts
  * Validates shift ownership
  * Ensures target shift belongs to target staff
  * Prevents duplicate active swap requests

---

[2025-12-12] [MOBILE-ATTENDANCE] Check-in/Check-out system - COMPLETED
- Created CheckInOutButton molecule component
  * Intelligent button state management
  * Shows "Check-in" when shift is active and not checked in
  * Shows "Check-out" when checked in but not checked out
  * Shows "Completed" when fully checked out
  * Disabled state for shifts not yet active
  * Loading state during API operations
  * Visual feedback with icons (enter/exit)
- Implemented AttendanceTimeInfo component
  * Displays check-in and check-out times
  * Shows duration worked
  * Formatted time display (HH:mm)
  * Duration calculation in hours and minutes
- Built AttendanceStatusBadge atom component
  * Visual status indicator (not started, in progress, completed)
  * Color coding: gray (not started), blue (in progress), green (completed)
  * Icons for each status
- Created shift_attendance table operations
  * Insert check-in record with timestamp
  * Update check-out record with timestamp
  * Calculate duration automatically
  * Link to shift via shift_id foreign key
- Added validation logic
  * Check-in only allowed within time window before/after shift start
  * Check-out only allowed after check-in
  * Prevents duplicate check-ins
- Integrated attendance into ShiftDetailScreen
  * Displays current attendance status
  * Shows check-in/out times if available
  * Prominently placed CheckInOutButton
  * Real-time status updates

---

[2025-12-12] [MOBILE-CHAT] Chat and messaging system - COMPLETED
- Implemented ChatListScreen (app/(app)/(tabs)/chat.tsx)
  * OrganizationChatSelector component for organization selection
  * List of organizations user belongs to
  * Organization logos/avatars
  * Tap to open conversation with organization
  * Empty state when no organizations
- Created ChatScreen (app/(app)/chat/[id].tsx)
  * Individual conversation view by organization ID
  * Message list with sender identification
  * Message input field
  * Send button
  * Auto-scroll to latest message
  * Real-time message updates
  * Timestamp display for each message
- Built OrganizationChatSelector molecule component
  * Displays organization cards
  * Organization name and logo
  * Member count display
  * Navigation to chat on selection
- Implemented basic messaging functionality
  * Send messages to organization channel
  * Receive messages from organization members
  * Message persistence in Supabase
  * Real-time message synchronization

---

[2025-12-12] [MOBILE-PROFILE] User profile screen - COMPLETED
- Created ProfileScreen (app/(app)/profile.tsx)
  * User avatar with initials and custom color
  * Display of staff name, CRM, specialty
  * Role/position display
  * Organization memberships
  * Logout button with confirmation
  * Clean, card-based layout
- Implemented logout functionality
  * Sign out from Supabase auth
  * Clear secure storage
  * Reset auth context state
  * Redirect to auth flow
  * Confirmation dialog before logout

---

[2025-12-12] [MOBILE-REALTIME] Real-time synchronization system - COMPLETED
- Created RealtimeProvider context (providers/realtime-provider.tsx)
  * Manages Supabase Realtime connection
  * Connection status tracking (connected/disconnected)
  * Auto-reconnect on failure
  * Channel management
  * Cleanup on unmount
- Implemented useRealtimeShifts hook (hooks/useRealtimeShifts.ts)
  * Subscribes to shifts table for current user
  * Handles INSERT, UPDATE, DELETE events
  * Merges realtime changes with fetched data
  * Maintains local state with real-time updates
  * Calculates pending shift count
  * Automatic re-sorting by start_time
- Implemented useRealtimeSwapRequests hook (hooks/useRealtimeSwapRequests.ts)
  * Subscribes to shift_swap_requests table
  * Filters for user's incoming and outgoing requests
  * Handles status changes in real-time
  * Calculates pending incoming request count
  * Updates UI instantly on changes
- Integrated realtime hooks throughout app
  * HomeScreen uses realtime shifts and swap requests
  * ScheduleScreen uses realtime shifts for calendar updates
  * RequestsScreen uses realtime swap requests
  * All screens automatically update without manual refresh
- Configured Supabase Realtime channels
  * Enabled row-level security (RLS) for realtime
  * Set up proper authentication for subscriptions
  * Optimized payload size with column selection

---

[2025-12-12] [MOBILE-NOTIFICATIONS] Push notifications system - COMPLETED
- Created NotificationProvider context (providers/notification-provider.tsx)
  * Request and manage notification permissions
  * Register device for push notifications
  * Handle incoming notifications
  * Background and foreground notification handling
  * Store notification token in Supabase
- Implemented notification handlers
  * Handle notification tap to navigate to relevant screen
  * Display in-app alerts for foreground notifications
  * Badge count management
  * Notification channels (Android)
- Integrated Expo Notifications
  * expo-notifications for push capabilities
  * expo-device for device identification
  * expo-constants for project configuration
- Configured notification triggers
  * New shift assigned
  * Shift swap request received
  * Shift swap accepted/declined
  * Check-in/check-out reminders
  * Schedule changes

---

[2025-12-12] [MOBILE-UI] UI components and design system - COMPLETED
- Created comprehensive atomic design component library
- Atoms (basic building blocks):
  * StatusBadge - Shift status indicators
  * PeriodBadge - Time period badges (manhã/tarde/noite)
  * ShiftTime - Formatted time display
  * AttendanceStatusBadge - Attendance status indicator
  * AnimatedSun - Animated sun for day scenes
  * AnimatedMoon - Animated moon for night scenes
  * AnimatedCloud - Floating cloud animations
- Molecules (composite components):
  * ShiftCard - Shift display card with all info
  * ShiftDetails - Detailed shift information panel
  * ShiftDateHeader - Formatted date header
  * CheckInOutButton - Check-in/out action button
  * AttendanceTimeInfo - Time tracking info display
  * OrganizationChatSelector - Organization selection for chat
  * SkyScene - Animated sky background (day/night/sunset)
- Organisms (complex components):
  * ShiftDetailHeader - Complete shift detail header with sky scene
- Base UI components:
  * Button - Customizable button with variants (primary, secondary, ghost)
  * Card - Card container with variants (elevated, outlined, flat)
  * Input - Text input with label and error states
  * Avatar - Circular avatar with initials and color
  * CRMInput - Specialized CRM input with masking
- Design system:
  * Consistent color palette (primary, success, warning, danger, neutral)
  * Typography scale
  * Spacing system
  * Border radius standards
  * Shadow/elevation levels
- Implemented custom animations
  * Smooth transitions using react-native-reanimated
  * Gesture handling with react-native-gesture-handler
  * Haptic feedback on interactions
  * Sky animations with sun/moon/clouds

---

[2025-12-12] [MOBILE-ROUTING] Expo Router file-based navigation - COMPLETED
- Configured Expo Router for type-safe navigation
- Implemented layout-based route structure
  * _layout.tsx - Root layout with providers
  * (auth)/_layout.tsx - Auth flow layout
  * (app)/_layout.tsx - Authenticated app layout
  * (app)/(tabs)/_layout.tsx - Bottom tab navigation
- Created route groups:
  * (auth) - Authentication screens (public)
  * (app) - Authenticated screens (protected)
  * (tabs) - Bottom tab navigation (home, schedule, requests, chat)
- Implemented navigation features:
  * Type-safe navigation with typed routes
  * Deep linking support with custom scheme (medsync://)
  * Back button handling
  * Tab bar customization with icons and labels
  * Route params typing
  * Automatic screen transitions
- Protected routes with auth guards
  * Redirect to auth if not authenticated
  * Redirect to app if already authenticated
- Configured tab bar:
  * Custom tab bar with haptic feedback
  * Icons from Expo Vector Icons (Ionicons)
  * Active/inactive states with color changes
  * Badge support for notifications

---

[2025-12-12] [MOBILE-BUILD] EAS Build configuration - COMPLETED
- Created eas.json configuration file
- Configured build profiles:
  * development - Development builds with dev client
  * preview - Preview builds for testing
  * production - Production builds for store submission
- Set up platform-specific configs (iOS and Android)
- Configured auto-increment build numbers
- Set up environment variables for different builds
- Integrated with Expo Updates for OTA updates
- Configured runtime versioning policy
- Ready for deployment to App Store and Play Store

---

[COMPLETED] Core Features Status:
✅ Authentication and registration flow
✅ Shift management (listing, calendar, details)
✅ Shift swap request system
✅ Check-in/Check-out attendance tracking
✅ Real-time synchronization (Supabase Realtime)
✅ Push notifications
✅ Chat/messaging system
✅ User profile management
✅ Atomic design component library
✅ File-based routing with Expo Router
✅ EAS Build and deployment configuration

---

[PENDING] Future Enhancements:
⏳ Offline mode with local storage sync
⏳ Advanced calendar features (week view, month view options)
⏳ Shift statistics and analytics
⏳ Document upload for attendance proof
⏳ Time tracking reports and exports
⏳ Multi-language support (i18n)
⏳ Dark mode theming
⏳ Biometric authentication (Face ID/Touch ID)
⏳ Voice notes in chat
⏳ File sharing in chat
⏳ Push notification preferences/settings
⏳ Calendar sync (Google Calendar, Apple Calendar)

---
[2025-12-12] [R001] Refactor shift detail modal to add interactive location with map integration - COMPLETED
- Refactored Location section in shift detail screen to add interactive map navigation
- Created FacilityLocationActions molecule component
  * Interactive buttons for Google Maps, Waze, and Apple Maps
  * Uses Linking API with proper URL schemes for each navigation app
  * Platform-specific behavior (Apple Maps on iOS, Google Maps fallback on Android)
  * Prioritizes latitude/longitude coordinates for precise navigation
  * Graceful fallback to formatted text addresses when coordinates unavailable
  * Haptic feedback on button interactions
  * Proper URL encoding for all address strings
- Created AddressDetailsCollapsible molecule component
  * Expandable/collapsible section showing full structured address details
  * Displays all facility_addresses fields (street, number, complement, neighborhood, city, state, postal_code)
  * Shows coordinates when available with monospace formatting
  * Smooth expand/collapse animation using react-native-reanimated
  * Chevron icon rotation animation
- Updated shift detail screen query
  * Added facility_addresses join to facilities relation
  * Fetches all address fields including latitude and longitude
  * Maintains backward compatibility with existing queries
- Refactored Location section UI
  * Three-tier rendering strategy:
    1. facility_addresses with coordinates → Best UX (structured address + map buttons with precise coords)
    2. facility_addresses without coordinates → Good UX (structured address + map buttons with text search)
    3. No facility_addresses → Fallback UX (legacy facilities.address + map buttons with text search)
  * Preserved facility name and icon display
  * Added expandable address details below facility info
  * Map navigation buttons positioned below address
  * All existing shift detail functionality unchanged
- Impact metrics:
  * 2 new reusable molecule components (300+ lines)
  * Enhanced user experience with one-tap navigation to any map app
  * Zero breaking changes - all existing functionality preserved
  * Proper TypeScript typing throughout
  * No linting errors introduced
  * Follows Atomic Design methodology (molecules)

---


---
[2025-12-12] [F001] Configure Supabase Storage bucket for profile images - COMPLETED
- Created dedicated 'profile-images' storage bucket in Supabase
- Bucket Configuration:
  * Public read access enabled (anyone can view profile images)
  * File size limit: 5 MB (5,242,880 bytes)
  * Allowed MIME types: image/jpeg, image/jpg, image/png, image/webp, image/gif
  * Bucket type: STANDARD
- Implemented comprehensive RLS policies:
  * SELECT policy: Public read access for all profile images
  * INSERT policy: Authenticated users can upload only to their own folder ({user_id}/*)
  * UPDATE policy: Authenticated users can update their own images
  * DELETE policy: Authenticated users can delete their own images
- Folder Structure Pattern:
  * Primary pattern: {user_id}/avatar.jpg
  * Versioned pattern: {user_id}/profile-{timestamp}.jpg
  * Multiple types: {user_id}/avatar.jpg, {user_id}/cover.jpg, etc.
  * Security: First folder level MUST match auth.uid() (enforced by RLS)
- Created migration file: supabase/migrations/20251212000000_create_profile_images_bucket.sql
  * Complete SQL migration with bucket creation
  * All 4 RLS policies with detailed comments
  * Verification queries and documentation
  * Idempotent (safe to run multiple times)
- Documentation created:
  * docs/storage-configuration.md (comprehensive guide)
    - Bucket configuration details
    - Folder structure patterns
    - Complete RLS policy explanations
    - TypeScript/React Native code examples
    - Upload, download, update, delete functions
    - Complete ProfileImageUpload component example
    - Database schema extension suggestions
    - Testing procedures
    - Security considerations
    - Troubleshooting guide
  * docs/storage-verification.md (verification report)
    - Bucket creation confirmation
    - Policy creation confirmation
    - Manual testing checklist
    - Next steps guide
- Verification completed:
  * Bucket successfully created in Supabase
  * All 4 policies active and verified via pg_policies
  * Public read access confirmed
  * User folder structure enforced
  * Ready for frontend integration
- Impact: Foundation for user profile image upload feature, enabling users to personalize their profiles with avatars

---
[2025-12-12] [F002] Add avatar_url column to profiles table schema - COMPLETED
- Added database schema support for storing profile image URLs
- Migration file created: supabase/migrations/20251212180000_add_avatar_url_to_medical_staff.sql
  * Added nullable TEXT column 'avatar_url' to medical_staff table
  * Column stores public URL to profile images in storage.profile-images bucket
  * Added comprehensive documentation comment with URL format example
  * Migration successfully applied to Supabase database (version 20251212200844)
- Database schema implementation:
  * Target table: public.medical_staff (app uses this as profiles table, not a separate profiles table)
  * Column type: TEXT (nullable)
  * Column allows NULL values for users without uploaded avatars
  * Documented expected URL format: https://{project}.supabase.co/storage/v1/object/public/profile-images/{user_id}/avatar.jpg
- TypeScript types generated and saved:
  * Created lib/database.types.ts with complete Database type definitions
  * Generated using Supabase MCP generate_typescript_types function
  * Types include avatar_url field in medical_staff Row, Insert, and Update types
  * Full type safety for all database tables, views, functions, and enums
  * Over 1,700 lines of comprehensive TypeScript types
- Verification completed:
  * Column successfully added to medical_staff table
  * Column configuration verified: data_type=text, is_nullable=YES, column_default=null
  * Comment properly set on column with documentation
  * Test query executed successfully on existing staff records (all show avatar_url as null)
  * Migration registered in Supabase migrations list
- Impact:
  * Enables storage of profile image URLs in user profiles
  * Foundation for upcoming profile image upload and display features (F003-F009)
  * Maintains backward compatibility (nullable column, existing records unaffected)
  * Proper type safety for TypeScript/React Native code
  * Zero breaking changes to existing functionality


---
[2025-12-12] [F003] Install and configure expo-image-picker with permissions - COMPLETED
- Installed expo-image-picker package (v17.0.10) for selecting images from device library
- Package Installation:
  * Installed via npx expo install expo-image-picker
  * Version ~17.0.10 compatible with Expo SDK 54
  * Added to dependencies in package.json
- iOS Permission Configuration:
  * Added NSPhotoLibraryUsageDescription to app.json
  * User-friendly message: "MedSync needs access to your photo library so you can select and upload a profile picture."
  * Permission prompt will display this message when requesting access
- Android Permission Configuration:
  * Added READ_MEDIA_IMAGES permission for Android 13+ (API level 33+)
  * Added READ_EXTERNAL_STORAGE permission for backward compatibility (Android 12 and below)
  * Configured in app.json android.permissions array
  * Supports both legacy and modern Android permission models
- Created useImagePicker Hook (hooks/useImagePicker.ts):
  * Comprehensive hook to encapsulate image selection logic
  * Permission Management:
    - checkPermission(): Checks current permission status without requesting
    - requestPermission(): Requests media library permissions with user feedback
    - Handles all permission states: GRANTED, DENIED, UNDETERMINED
    - Special handling for "Don't ask again" scenario with settings guidance
  * Image Selection:
    - pickImage(): Launches image picker with configurable options
    - Supports customizable aspect ratio, quality, and media types
    - Default configuration: 1:1 aspect, 80% quality, images only
    - Returns normalized ImagePickerResult with uri, dimensions, and metadata
  * State Management:
    - permissionStatus: Current permission status (null | PermissionStatus)
    - isRequestingPermission: Boolean flag for permission request in progress
    - isPickingImage: Boolean flag for image picker active state
  * Error Handling:
    - Try-catch blocks for all async operations
    - User-friendly Alert dialogs for permission denials
    - Platform-specific guidance (iOS: open settings prompt, Android: manual instructions)
    - Console error logging for debugging
  * TypeScript Interfaces:
    - ImagePickerResult: Normalized result type (uri, width, height, type, fileName, fileSize)
    - UseImagePickerOptions: Configuration options (allowsEditing, aspect, quality, mediaTypes)
    - UseImagePickerReturn: Hook return type with all methods and state
  * Documentation:
    - Comprehensive JSDoc comments for all interfaces and functions
    - Usage examples in hook documentation
    - Clear parameter and return type descriptions
- Exported Hook in hooks/index.ts:
  * Added useImagePicker to feature hooks section
  * Exported all TypeScript types for consumer convenience
  * Types: ImagePickerResult, UseImagePickerOptions, UseImagePickerReturn
- Verification:
  * Package successfully installed and added to package.json
  * iOS permission configured in app.json infoPlist
  * Android permissions configured in app.json permissions array
  * Hook created with 260+ lines of robust implementation
  * Project builds successfully with no errors (verified with expo export)
  * TypeScript types properly defined and exported
  * All exports verified in hooks/index.ts
- Impact:
  * Foundation for profile image upload feature (F004-F009)
  * Reusable hook can be used anywhere in the app for image selection
  * Proper permission handling ensures App Store and Play Store compliance
  * User-friendly error messages improve UX for permission scenarios
  * Follows React best practices with useCallback hooks for performance
  * Zero breaking changes to existing functionality
- All Acceptance Criteria Met:
  ✅ expo-image-picker package installed
  ✅ iOS NSPhotoLibraryUsageDescription added to app.json
  ✅ Android READ_MEDIA_IMAGES permission configured
  ✅ useImagePicker hook created with permission request logic
  ✅ Permission denied scenario handled with user feedback
---
[2025-12-12] [F004] Implement image cropping functionality with expo-image-manipulator - COMPLETED
- Installed expo-image-manipulator package (v14.0.8)
- Package Installation:
  * Installed via npx expo install expo-image-manipulator
  * Version ~14.0.8 compatible with Expo SDK 54
  * Added to dependencies in package.json
- Created useImageCropper Hook (hooks/useImageCropper.ts):
  * Comprehensive hook for transforming images into circular avatar format
  * Image Cropping Logic:
    - Accepts image URI from device (e.g., from expo-image-picker)
    - Analyzes image dimensions to calculate center square crop
    - Extracts largest possible square from center of image
    - Handles both landscape and portrait orientations
    - Crop calculation: originX = (width - cropSize) / 2, originY = (height - cropSize) / 2
  * Image Transformations:
    - Step 1: Crop to 1:1 aspect ratio (center square extraction)
    - Step 2: Resize to exactly 512x512px for consistency
    - Output format: JPEG with 0.9 compression quality (90%)
  * State Management:
    - isCropping: Boolean flag for crop operation in progress
    - error: String error message from last operation (null on success)
  * Error Handling:
    - Input validation (checks for valid URI string)
    - Try-catch blocks for all async operations
    - Detailed console logging for debugging
    - User-friendly error messages
    - Returns null on failure
  * TypeScript Interfaces:
    - CropResult: Result type (uri, width, height)
    - UseImageCropperOptions: Configuration options (targetSize, quality)
    - UseImageCropperReturn: Hook return type (cropImage, isCropping, error)
  * Performance Optimizations:
    - useCallback hook prevents unnecessary re-renders
    - Configurable target size and quality for flexibility
    - Default 512x512px suitable for most avatar use cases
  * Documentation:
    - Comprehensive JSDoc comments for all interfaces
    - Detailed function documentation with examples
    - Explains crop logic and transformation steps
    - Notes about circular masking in UI layer (handled by Avatar component)
- Exported Hook in hooks/index.ts:
  * Added useImageCropper to feature hooks section
  * Exported all TypeScript types for consumer convenience
  * Types: CropResult, UseImageCropperOptions, UseImageCropperReturn
- Implementation Details:
  * 210 lines of robust, well-documented code
  * Follows React best practices with hooks
  * Maintains consistency with existing hook patterns (useImagePicker, useShiftAttendance)
  * Edge case handling:
    - Images already square: Skip crop, only resize
    - Images smaller than target: Upscale to 512x512px
    - Images larger than target: Downscale to 512x512px
    - Invalid URIs: Return null with error message
- Verification:
  * Package successfully installed and added to package.json
  * Hook created with full implementation
  * Project builds successfully (verified with expo export)
  * TypeScript types properly defined and exported
  * All exports verified in hooks/index.ts
  * Zero TypeScript errors from new code
  * Zero breaking changes to existing functionality
- Impact:
  * Foundation for profile image upload feature (F005-F009)
  * Ensures all avatars have consistent dimensions (512x512px)
  * Prepares images for optimal storage and display performance
  * Reusable hook can be used anywhere in app for image cropping
  * Separates concerns: picking (useImagePicker) vs cropping (useImageCropper)
- All Acceptance Criteria Met:
  ✅ expo-image-manipulator package installed
  ✅ useImageCropper hook created with crop logic
  ✅ Images cropped to 1:1 aspect ratio (512x512px)
  ✅ Circular crop mask applied for avatar format (note: square prepared here, circular masking in UI)
  ✅ Error handling implemented for manipulation failures

[2025-12-12] [F005] Create uploadProfileImage utility function for Supabase Storage - COMPLETED
- Created lib/profile-image.ts utility module (441 lines)
- Main Functions Implemented:
  * uploadProfileImage(): Complete upload workflow with authentication and cleanup
  * deleteProfileImage(): Delete specific profile image
  * getProfileImageUrl(): Convenience function to get public URL
  * deleteOldAvatars(): Internal helper to clean up old avatar files
  * imageUriToBlob(): Internal helper to convert image URI to blob for upload
- TypeScript Types and Error Handling:
  * ProfileImageErrorCode enum: UPLOAD_FAILED, DELETE_FAILED, INVALID_INPUT, UNAUTHORIZED, FETCH_FAILED, SESSION_NOT_FOUND
  * ProfileImageError class: Custom error with error codes and original error tracking
  * ProfileImageUploadOptions interface: userId, imageUri, filenameSuffix (default: 'avatar'), deleteOldAvatars (default: true)
  * ProfileImageUploadResult interface: publicUrl, path, fullPath
- uploadProfileImage() Workflow:
  1. Input Validation: Validates userId and imageUri are non-empty strings
  2. Authentication Check: Verifies user session exists via Supabase auth
  3. Authorization Check: Ensures userId matches authenticated user (security)
  4. Old Avatar Cleanup: Lists and deletes existing avatar-*.jpg files in user folder
  5. Image Conversion: Fetches image from URI and converts to Blob
  6. Filename Generation: Creates unique filename with timestamp (avatar-{timestamp}.jpg)
  7. Upload to Storage: Uploads to profile-images/{userId}/avatar-{timestamp}.jpg
  8. Public URL Generation: Gets public URL using getPublicUrl method
  9. Return Result: Returns { publicUrl, path, fullPath }
- Upload Configuration:
  * Bucket: profile-images (created in F001)
  * Path pattern: {userId}/avatar-{timestamp}.jpg
  * Content-Type: image/jpeg
  * Cache-Control: 3600 seconds (1 hour)
  * Upsert: false (timestamp ensures uniqueness)
- Old Avatar Cleanup Logic:
  * Lists all files in user folder with limit 100
  * Filters for files matching pattern: avatar-*.jpg
  * Deletes all matching files before upload
  * Graceful error handling: logs errors but doesn't block upload
  * Prevents accumulation of old avatar files
- Error Handling:
  * Comprehensive try-catch blocks in all async functions
  * Custom ProfileImageError class with error codes
  * Input validation with typed error messages
  * Authentication verification with SESSION_NOT_FOUND error
  * Authorization check with UNAUTHORIZED error
  * Upload failure handling with UPLOAD_FAILED error
  * Delete failure handling with DELETE_FAILED error
  * Fetch failure handling for URI to blob conversion
  * All errors include original error for debugging
- Security Features:
  * User can only upload to their own folder (userId must match session.user.id)
  * RLS policies enforce folder-level access control (configured in F001)
  * Session validation on every operation
  * No cross-user uploads possible
- Additional Helper Functions:
  * getProfileImageUrl(userId, filename): Gets public URL for existing image
  * deleteProfileImage(userId, filename): Deletes specific image with auth check
  * Both include input validation and authorization checks
- Logging and Debugging:
  * Comprehensive console logging throughout workflow
  * [profile-image] prefix for easy log filtering
  * Logs include: upload start, user auth, old avatar cleanup, conversion, upload success, URL generation
  * Error logs include full error details for debugging
- React Native Compatibility:
  * Handles both file:// URIs (React Native) and web URIs
  * Uses fetch() API for universal blob conversion
  * Works seamlessly with expo-image-picker and expo-image-manipulator outputs
- Integration Points:
  * Works with profile-images bucket (F001)
  * Accepts images from expo-image-picker (F003)
  * Accepts cropped images from expo-image-manipulator (F004)
  * Ready for use in ProfileAvatarUpload component (F007)
  * Returns URL for updating medical_staff.avatar_url column (F002, F006)
- Verification:
  * File created successfully: lib/profile-image.ts
  * TypeScript compilation successful (verified with expo export)
  * All exports properly typed and documented
  * Zero breaking changes to existing functionality
  * Project builds successfully for iOS, Android, and Web
- Documentation:
  * Comprehensive JSDoc comments for all interfaces and functions
  * Detailed function documentation with examples
  * Parameter and return type descriptions
  * Remarks about security, behavior, and error handling
  * Usage examples in code comments
- Impact:
  * Foundation for profile image upload feature (F006-F009)
  * Reusable utility for any image upload needs
  * Proper separation of concerns: upload logic separate from UI
  * Type-safe error handling throughout
  * Production-ready with comprehensive error handling and logging
- All Acceptance Criteria Met:
  ✅ lib/profile-image.ts file created with uploadProfileImage function
  ✅ Function uploads to correct bucket path (user_id/avatar-{timestamp}.jpg)
  ✅ Public URL returned upon successful upload
  ✅ Old avatar images deleted before uploading new one
  ✅ Comprehensive error handling with typed errors

---
